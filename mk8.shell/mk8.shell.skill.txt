mk8.shell — agent skill reference

You submit JSON scripts. The server compiles and executes them.
You never interact with a real shell. There is no eval, no pipes,
no chaining, no shell expansion. Arguments are structured arrays.

Every command executes inside a named sandbox. The sandbox ID
(e.g. "Banana") identifies which isolated workspace to use.
The server resolves the sandbox to a local directory, verifies
its cryptographically signed environment, executes the command
in an isolated task container, then disposes all state. Nothing
transfers between commands.

You CANNOT register, create, or manage sandboxes. If a sandbox
does not exist, tell the user to register it using mk8.shell.startup.


== submitting a script ================================================

You provide a sandbox ID and a script. mk8.shell does the rest:
it looks up the sandbox in its own %APPDATA%/mk8.shell registry,
verifies the cryptographic signature, builds the workspace, compiles
your script, executes it, and returns results. The sandbox ID is
NOT part of the script JSON — it is a separate parameter.

Script format:

{
  "operations": [
    { "verb": "...", "args": ["..."] }
  ],
  "options": { ... },
  "cleanup": [ ... ]
}

Every operation needs "verb" and "args". All other fields are optional.


== verbs and args =====================================================

--- files ---
FileRead       [path]                read entire file
FileWrite      [path, content]       overwrite file
FileAppend     [path, content]       append to file
FileDelete     [path]                delete file
FileExists     [path]                returns "true"/"false"
FileList       [path, pattern?]      list files, optional glob
FileCopy       [src, dst]            copy file
FileMove       [src, dst]            move/rename file
FileHash       [path, algorithm?]    sha256 (default), sha512, md5

--- files: structured edits ---
FileTemplate   [outputPath]          requires "template" field (see below)
FilePatch      [targetPath]          requires "patches" field (see below)

--- files: batch ---
FileWriteMany  [p1, c1, p2, c2...]   pairs of path+content, max 64
FileCopyMany   [s1, d1, s2, d2...]   pairs of src+dst, max 64
FileDeleteMany [p1, p2, p3...]       list of paths, max 64

--- directories ---
DirCreate      [path]                mkdir -p equivalent
DirDelete      [path]                rm -rf equivalent
DirList        [path]                immediate children
DirExists      [path]                returns "true"/"false"
DirTree        [path, depth?]        recursive listing, depth 1-5, default 3

--- process ---
ProcRun        [binary, arg, arg...] run a whitelisted command template

--- git (via ProcRun, command-template whitelist) ---
Git is available through ProcRun with strict constraints.
Read-only commands: status, log, diff, branch, remote, ls-files, tag, describe.
Write commands: add, commit, stash, checkout, switch.
Protected branches are BANNED — see ProcRun section below.

--- http ---
HttpGet        [url]
HttpPost       [url, body?]
HttpPut        [url, body?]
HttpDelete     [url]

--- text ---
TextRegex      [input, pattern]      match regex, 2s timeout
TextReplace    [input, old, new]     literal replacement
JsonParse      [input]               validate + pretty-print
JsonQuery      [input, jsonpath]     extract value

--- environment (read-only) ---
EnvGet         [name]                allowlist only (see below)

--- system info (no args) ---
SysWhoAmI      []                    current user
SysPwd         []                    working directory
SysHostname    []                    machine name
SysUptime      []
SysDate        []                    UTC

--- control flow (expanded at compile time, not runtime) ---
ForEach        []                    requires "forEach" field
If             []                    requires "if" field

--- composition ---
Include        [fragmentId]          inline admin-approved fragment


== variables ==========================================================

Resolved at compile time. Not shell env vars.

$WORKSPACE   sandbox root directory (from local registry)
$CWD         working directory (defaults to sandbox root)
$USER        OS username
$PREV        stdout of previous step (only when pipeStepOutput: true)

Additional variables from the sandbox's signed env file are also
available (loaded automatically at command startup).

Use in args: { "args": ["$WORKSPACE/src/app.ts"] }

$PREV is always empty when pipeStepOutput is false (default).


== named captures =====================================================

Any step can capture its stdout:

{ "verb": "ProcRun", "args": ["dotnet", "build"], "captureAs": "BUILD_OUT" }
{ "verb": "FileWrite", "args": ["$WORKSPACE/log.txt", "$BUILD_OUT"] }

Max 16 captures per script. Cannot reuse names. Cannot override
WORKSPACE, CWD, USER, PREV, ITEM, INDEX.

Captures from process-spawning steps (ProcRun) are blocked in
ProcRun args — same rule as $PREV.


== per-step fields ====================================================

maxRetries     int       retry on non-zero exit
stepTimeout    TimeSpan  e.g. "00:02:00", capped by server ceiling
label          string    unique step label for jump targets
onFailure      string    "goto:<label>" — forward jumps only
captureAs      string    capture stdout into named variable
template       object    for FileTemplate verb only
patches        array     for FilePatch verb only


== options ============================================================

maxRetries       0          script-level retry default
retryDelay       "00:00:02" doubles each attempt
stepTimeout      "00:00:30" per-step ceiling
scriptTimeout    "00:05:00" total script ceiling
failureMode      "StopOnFirstError" | "ContinueOnError" | "StopAndCleanup"
maxOutputBytes   1048576    truncation limit for stdout
maxErrorBytes    262144     truncation limit for stderr
pipeStepOutput   false      set true to enable $PREV


== cleanup ============================================================

When failureMode is "StopAndCleanup", add a "cleanup" array.
These run after failure with best-effort (ContinueOnError) semantics.

{
  "operations": [ ... ],
  "cleanup": [
    { "verb": "DirDelete", "args": ["$WORKSPACE/tmp"] },
    { "verb": "FileDelete", "args": ["$WORKSPACE/build.lock"] }
  ],
  "options": { "failureMode": "StopAndCleanup" }
}


== labels and failure jumps ===========================================

{ "verb": "ProcRun", "args": ["dotnet", "build"], "onFailure": "goto:cleanup" },
{ "verb": "ProcRun", "args": ["dotnet", "test"] },
{ "verb": "FileWrite", "args": ["$WORKSPACE/done.txt", "ok"], "label": "cleanup" }

Forward jumps only. No backward jumps. Labels must be unique.
Alphanumeric, hyphens, underscores. Max 64 chars.


== FileTemplate =======================================================

{
  "verb": "FileTemplate",
  "args": ["$WORKSPACE/app/config.json"],
  "template": {
    "source": "$WORKSPACE/templates/config.template.json",
    "values": { "DB_HOST": "db.internal", "PORT": "5432" }
  }
}

Replaces {{DB_HOST}} and {{PORT}} in the template. Max 64 keys.
Values must be literal strings. $ characters in values are rejected.


== FilePatch ==========================================================

{
  "verb": "FilePatch",
  "args": ["$WORKSPACE/app/config.yaml"],
  "patches": [
    { "find": "port: 3000", "replace": "port: 8080" },
    { "find": "debug: true", "replace": "debug: false" }
  ]
}

Literal find/replace applied in order. Max 32 patches.
$ characters in find/replace are rejected.


== ForEach ============================================================

{
  "verb": "ForEach",
  "forEach": {
    "items": ["a.txt", "b.txt", "c.txt"],
    "body": { "verb": "FileCopy", "args": ["$WORKSPACE/$ITEM", "$WORKSPACE/backup/$ITEM"] }
  }
}

$ITEM = current item, $INDEX = 0-based index.
Max 256 items. Expanded at compile time — not a runtime loop.
No nested ForEach.


== If =================================================================

{
  "verb": "If",
  "if": {
    "predicate": { "kind": "PrevContains", "args": ["Build succeeded"] },
    "then": { "verb": "FileWrite", "args": ["$WORKSPACE/status.txt", "build ok"] }
  }
}

Predicate kinds:
  PrevContains  [substring]         true if $PREV contains it
  PrevEmpty     []                  true if $PREV is blank
  EnvEquals     [name, expected]    true if env var matches
  FileExists    [path]              evaluated at runtime
  DirExists     [path]              evaluated at runtime

No else branch. No boolean operators.


== Include ============================================================

{ "verb": "Include", "args": ["setup-workspace"] }

Inlines an admin-approved fragment by ID. You cannot define fragments —
only reference IDs the server has registered.


== ProcRun command-template whitelist ==================================

ProcRun uses a STRICT COMMAND-TEMPLATE WHITELIST. There is no "allowed
binary + blocked flags" model. Every invocation must match a registered
template EXACTLY. You cannot inject free text into any argument position.

Templates and word lists are compile-time constants. They cannot be
changed at runtime.

--- how argument slots work ---

Each argument position has a typed slot:

  Choice         must be one of a fixed set (e.g. Release or Debug)
  SandboxPath    must resolve inside $WORKSPACE
  AdminWord      must be a single entry from a named word list
  IntRange       must be an integer in [min, max]
  ComposedWords  split on spaces, each word must be in a named word list
                 (max 12 words). Spaces are safe — ArgumentList passes
                 the whole string as one OS argument. No shell involved.
  CompoundName   runtime base name + optional compile-time suffix.
                 Used for project names only (the ONLY runtime exception).

--- CompoundName (project names) ---

Your administrator sets base project names at startup (e.g. "Banana").
The source defines compile-time suffixes (Api, Core, Tests, etc.).
You compose by concatenation or dot-separation:

  Base "Banana" with suffixes:
    "Banana"                → base alone                     → OK
    "BananaApi"             → base + "Api"                   → OK
    "Banana.Api"            → base + "." + "Api"             → OK
    "Banana.Application.API"→ base + "." + "Application.API" → OK
    "BananaApp123"          → no such suffix "App123"        → REJECTED
    "FooApi"                → "Foo" not a registered base    → REJECTED

If no base names are configured, dotnet new -n is unavailable.
dotnet new WITHOUT -n still works (uses directory name).

--- ComposedWords examples ---

Used for git commit messages. You compose by combining words with spaces:

  "Fix build errors"       → ["Fix","build","errors"]      → all in list → OK
  "Add auth middleware"    → ["Add","auth","middleware"]    → all in list → OK
  "Api 1 2 3"              → ["Api","1","2","3"]            → all in list → OK
  "WIP"                    → ["WIP"]                        → in list     → OK
  "Api123"                 → ["Api123"] as one word         → NOT in list → REJECTED
  "I hacked the mainframe" → "hacked" NOT in list           → REJECTED

ComposedWords is NOT concatenation. "Api 1 2 3" (4 words) works.
"Api123" (1 word) does not. This is by design.

--- dotnet commands ---

  dotnet --version
  dotnet --info
  dotnet build       [--configuration Release|Debug] [--no-restore] [-o path]
  dotnet publish     [--configuration Release|Debug] [--no-restore] [-o path]
  dotnet test        [--configuration Release|Debug] [--no-restore] [--no-build]
  dotnet clean       [--configuration Release|Debug]
  dotnet restore     [--no-cache]
  dotnet format      [--verify-no-changes]
  dotnet new <template> [-n <name>] [-o path]
    template: from DotnetTemplates list (console, classlib, webapi, etc.)
    name: CompoundName — runtime base + optional compile-time suffix
          (e.g. "BananaApi", "Banana.Core", "Banana")
  dotnet ef migrations add <name>
    name: from MigrationNames list (Initial, AddUsers, etc., plus A-Z, 0-9)
  dotnet ef migrations list
  dotnet ef migrations script [--idempotent] [-o path]
  dotnet ef dbcontext info
  dotnet ef dbcontext list

--- git commands ---

READ-ONLY (no repository state changed):

  git --version
  git status         [--short | -s | --porcelain]
  git log --oneline  [-n 1-100] [--all] [--no-decorate]
  git diff           [--staged] [--cached] [--stat] [--name-only] [--name-status]
  git diff <path>    [--staged] [--cached]
  git branch         [--list | -a | --all | -r]
  git remote         [-v]
  git remote add <name> <url>    name from RemoteNames, url from runtime config
  git remote remove <name>       name from RemoteNames
  git rev-parse HEAD
  git rev-parse --short HEAD
  git ls-files
  git tag --list
  git tag -l
  git describe       [--tags] [--always]

WRITE (constrained to word lists):

  git add <paths...>                   SandboxPath (variadic)
  git add .
  git add -A
  git commit -m "<message>"            ComposedWords from CommitWords vocabulary
  git stash
  git stash pop
  git stash list
  git stash drop
  git checkout <branch>                AdminWord from BranchNames
  git checkout -b <branch>             AdminWord from BranchNames
  git switch <branch>                  AdminWord from BranchNames
  git switch -c <branch>               AdminWord from BranchNames

PROTECTED BRANCHES — BANNED:
  main, master, develop, staging, production, live, release, release/*,
  trunk. These are intentionally excluded from BranchNames. You must
  NEVER operate on branches used for live or master development. All
  your work must happen in a feature/bugfix/hotfix branch. Merging to
  protected branches requires the dangerous-shell path with human
  approval.

NOT WHITELISTED (require dangerous-shell path):
  push, pull, merge, rebase, reset, clean, clone, config, submodule,
  am, apply, filter-branch, cherry-pick, bisect, gc, fsck, reflog.

--- git commit message vocabulary (CommitWords) ---

You compose commit messages by combining words with spaces. Each word
must be in the CommitWords vocabulary. Max 12 words per message.

Verbs: Add Fix Update Remove Delete Refactor Move Rename Clean Optimize
       Configure Wire Scaffold Extract Inline Format Implement Replace
       Merge Split Revert Enable Disable Restore Sync Simplify Improve
       Reorganize Consolidate Introduce Deprecate Drop Bump Pin Unpin
Adjectives: Initial Minor Major Quick Temporary Deprecated Breaking
            Critical Partial Missing Unused Duplicate Stale Draft
            Experimental Internal Public Private New Old Default Custom Base
Nouns: commit migration migrations schema tests test build builds
       errors error typos typo code files file config configuration
       dependencies dependency imports import comments comment
       documentation docs README CHANGELOG endpoints endpoint
       commands command middleware project projects services service
       method methods class classes interface interfaces logging
       validation handling namespace namespaces package packages
       module modules component components feature features bugfix
       hotfix release version setup cleanup logic flow pipeline
       workflow response request route routes handler handlers
       controller query queries index indexes table tables column
       columns constraint constraints relation relations key keys
       property properties field fields parameter parameters type
       types enum enums seed data baseline snapshot template templates
       factory helper options settings constants
Domain: auth authentication authorization permissions agents agent
        channels channel contexts context models model providers
        provider jobs job tasks task skills skill resources resource
        containers container devices device messages message roles role
        users user transcription audio scheduler tokens token encryption
        API CLI DI EF DB UI REST gRPC JSON YAML XML
Connectors: up in for to from with and of on at by as into across
States: work progress checkpoint WIP
Letters: A-Z (case-insensitive)
Digits: 0-9

--- node/npm commands ---

  node --version
  npm --version
  npm ls             [--depth 0-10] [--all] [--json]
  npm outdated       [--json]

--- cargo commands ---

  cargo --version

--- archive commands (create/list ONLY, no extraction) ---

  tar -tf <path>
  tar -cf <out> <inputs...>
  tar -czf <out> <inputs...>
  gzip <path>
  gunzip <path>
  zip <out> <inputs...>
  unzip -l <path>

--- read-only tools (SandboxPath args only, no free text) ---

  cat <path>
  head -n <1-1000> <path>
  tail -n <1-1000> <path>
  wc -l|-w|-c <path>
  sort <path>
  uniq <path>
  diff <path1> <path2>
  sha256sum <path>
  md5sum <path>
  base64 <path>
  base64 -d <path>

--- permanently blocked binaries (cannot be overridden) ---

  bash sh zsh fish dash cmd powershell pwsh
  python python2 python3 pip pip3 perl ruby lua php
  npx env xargs nohup sudo su doas pkexec
  curl wget find ssh scp rsync nc socat
  chmod chown systemctl crontab dd strace


== runtime configuration (admin-set, the ONLY runtime exception) ======

Your administrator provides these at startup via Mk8RuntimeConfig.
They are baked into the whitelist at construction and cannot change.

  ProjectBases     base project names for dotnet new -n (max 32)
                   e.g. ["Banana", "SharpClaw"]
                   Combined with compile-time suffixes:
                   Api, Core, Infrastructure, Contracts, Tests, Utils,
                   Client, Server, Worker, Service, Web, Grpc, Shared,
                   Common, Domain, Data, Models, Handlers, Extensions,
                   Application.API, Application.Core,
                   Application.Infrastructure, Application.Contracts,
                   Application.Tests, PublicAPI, UITests

  GitRemoteUrls    allowed git remote URLs for git remote add (max 16)
                   e.g. ["https://github.com/org/repo.git"]

If not configured, dotnet new -n and git remote add are unavailable.


== EnvGet allowlist ===================================================

HOME USERPROFILE USER USERNAME PATH LANG LC_ALL TZ TERM
PWD HOSTNAME SHELL EDITOR DOTNET_ROOT NODE_ENV

Any name containing KEY, SECRET, TOKEN, PASSWORD, CONN, AUTH,
PRIVATE, ENCRYPT, JWT, CERTIFICATE, APIKEY is blocked.


== HTTP rules =========================================================

Scheme must be http or https. Port must be 80 or 443.
No embedded credentials in the URL.
Blocked hosts: localhost, 169.254.169.254, metadata.google.internal.
Private/link-local IPs are blocked.


== path rules =========================================================

All paths must resolve inside $WORKSPACE (the sandbox).

FORBIDDEN FILES (blocked on ALL operations — read, write, everything):
  mk8.shell.env, mk8.shell.signed.env
  These are sandbox environment files managed exclusively by the user
  or mk8.shell.startup. You cannot read, write, copy, move, delete,
  hash, or list them. Any attempt will fail.

Write targets (.exe .dll .js .mjs .cjs .so .dylib and others) are
blocked. You can write .sh .py .ps1 .bat etc. because their
interpreters are blocked in ProcRun.

Writes to .git/ paths are BLOCKED — you cannot create hooks, modify
config, or inject objects into .git/ internals. Git metadata is
managed by whitelisted git commands only.

Write-blocked config filenames:
  Makefile, GNUmakefile, CMakeLists.txt, Dockerfile, .npmrc,
  Directory.Build.props, Directory.Build.targets, Directory.Packages.props,
  nuget.config, package.json, build.rs, Cargo.toml,
  setup.py, setup.cfg, pyproject.toml, .gitattributes, .gitmodules,
  mk8.shell.env, mk8.shell.signed.env

Write-blocked extensions:
  .exe .com .scr .msi .msp .dll .bin .run .appimage .elf .so .dylib
  .js .mjs .cjs .jse .wsf .wsh .msh .vbs .vbe
  .csproj .fsproj .vbproj .proj .targets .props .sln .rs

Build $WORKSPACE-relative paths without knowing the absolute root:
  $WORKSPACE/src/app.ts       (use $WORKSPACE prefix)
  $CWD/output/log.txt         (use $CWD prefix)

No .. segments. No absolute paths in path components.


== what will always fail ==============================================

- Any verb not in the list above
- Shell syntax in args: pipes |, chains &&, redirects >, subshells $()
- Running bash, python, powershell, or any blocked binary
- Any ProcRun invocation that doesn't match a registered template
- Unregistered flags on any binary (e.g. git -c, dotnet run)
- Free text in any argument position (must match a typed slot)
- Writing .exe, .dll, .js, .so, or other blocked extensions
- Writing to .git/ paths (hooks, config, objects)
- Writing .gitattributes or .gitmodules
- Reading or writing mk8.shell.env or mk8.shell.signed.env
- Checking out protected branches (main, master, develop, staging,
  production, live, release/*, trunk)
- Commit messages containing words not in CommitWords vocabulary
- Paths that escape the sandbox via .. or absolute paths
- $PREV or process-captured variables in ProcRun args
- $ characters inside template values or patch find/replace
- More than 1024 total operations after expansion
- ForEach with more than 256 items
- Nesting depth greater than 3


== common patterns ====================================================

--- build and capture output ---
{
  "operations": [
    { "verb": "ProcRun", "args": ["dotnet", "build"], "captureAs": "BUILD" },
    { "verb": "FileWrite", "args": ["$WORKSPACE/build.log", "$BUILD"] }
  ],
  "options": { "pipeStepOutput": true }
}

--- scaffold multiple files ---
{
  "operations": [
    {
      "verb": "FileWriteMany",
      "args": [
        "$WORKSPACE/src/index.ts", "export {}",
        "$WORKSPACE/src/config.ts", "export const config = {}",
        "$WORKSPACE/README.md", "# Project"
      ]
    }
  ]
}

--- conditional deploy ---
{
  "operations": [
    { "verb": "ProcRun", "args": ["dotnet", "build"] },
    {
      "verb": "If",
      "if": {
        "predicate": { "kind": "PrevContains", "args": ["Build succeeded"] },
        "then": { "verb": "ProcRun", "args": ["dotnet", "publish", "-o", "$WORKSPACE/out"] }
      }
    }
  ],
  "options": { "pipeStepOutput": true }
}

--- backup files before editing ---
{
  "operations": [
    {
      "verb": "ForEach",
      "forEach": {
        "items": ["config.yaml", "settings.json"],
        "body": { "verb": "FileCopy", "args": ["$WORKSPACE/$ITEM", "$WORKSPACE/backup/$ITEM"] }
      }
    },
    {
      "verb": "FilePatch",
      "args": ["$WORKSPACE/config.yaml"],
      "patches": [{ "find": "port: 3000", "replace": "port: 8080" }]
    }
  ]
}

--- build with cleanup on failure ---
{
  "operations": [
    { "verb": "DirCreate", "args": ["$WORKSPACE/staging"] },
    { "verb": "ProcRun", "args": ["dotnet", "publish", "-o", "$WORKSPACE/staging"] }
  ],
  "cleanup": [
    { "verb": "DirDelete", "args": ["$WORKSPACE/staging"] }
  ],
  "options": { "failureMode": "StopAndCleanup" }
}

--- check file hash ---
{
  "operations": [
    { "verb": "FileHash", "args": ["$WORKSPACE/bin/app.dll", "sha256"], "captureAs": "HASH" },
    { "verb": "FileWrite", "args": ["$WORKSPACE/checksums.txt", "$HASH"] }
  ],
  "options": { "pipeStepOutput": true }
}

--- git: create branch, edit, commit ---
{
  "operations": [
    { "verb": "ProcRun", "args": ["git", "checkout", "-b", "feature/auth"] },
    { "verb": "FileWrite", "args": ["$WORKSPACE/src/auth.cs", "// auth module"] },
    { "verb": "ProcRun", "args": ["git", "add", "."] },
    { "verb": "ProcRun", "args": ["git", "commit", "-m", "Add authentication module"] }
  ]
}

--- git: check status, diff, and log ---
{
  "operations": [
    { "verb": "ProcRun", "args": ["git", "status", "--short"], "captureAs": "STATUS" },
    { "verb": "ProcRun", "args": ["git", "diff", "--stat"], "captureAs": "DIFF" },
    { "verb": "ProcRun", "args": ["git", "log", "--oneline", "-n", "10"], "captureAs": "LOG" },
    { "verb": "FileWrite", "args": ["$WORKSPACE/git-report.txt", "$STATUS\n\n$DIFF\n\n$LOG"] }
  ],
  "options": { "pipeStepOutput": true }
}

--- git: stash, switch branch, pop ---
{
  "operations": [
    { "verb": "ProcRun", "args": ["git", "stash"] },
    { "verb": "ProcRun", "args": ["git", "switch", "feature/api"] },
    { "verb": "ProcRun", "args": ["git", "stash", "pop"] }
  ]
}
